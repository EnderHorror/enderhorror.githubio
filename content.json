{"meta":{"title":"Ender的博客","subtitle":"","description":"","author":"Ender","url":"https://enderhorror.github.io/enderhorror.githubio","root":"/enderhorror.githubio/"},"pages":[],"posts":[{"title":"Unity异步加载资源","slug":"AsyncLoadAsset","date":"2021-05-10T08:13:20.540Z","updated":"2021-05-10T08:25:14.300Z","comments":true,"path":"2021/05/10/AsyncLoadAsset/","link":"","permalink":"https://enderhorror.github.io/enderhorror.githubio/2021/05/10/AsyncLoadAsset/","excerpt":"","text":"Unity异步加载资源Resource.Load()是经常用来加载资源的,但是如果一个资源比较大或者Prefabs的子物体特别对使用同步加载就会引起卡顿,通过异步加载的方式可以避免卡顿 同步加载资源 1234567891011/// &lt;summary&gt;/// 同步加载资源/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;/// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T LoadResource&lt;T&gt;(string path)where T:Object&#123; T resource = Resources.Load&lt;T&gt;(path); else return resource;&#125; 异步加载资源 123456789101112131415161718/// &lt;summary&gt;/// 异步加载资源/// &lt;/summary&gt;/// &lt;param name=&quot;action&quot;&gt;回调委托&lt;/param&gt;public void LoadResourceAsync&lt;T&gt;(string path, UnityAction&lt;T&gt; action) where T : Object&#123; StartCoroutine(I_LoadResourceAsync&lt;T&gt;(path, action));&#125;//将异步的东西都放在协程里面做IEnumerator I_LoadResourceAsync&lt;T&gt;(string path,UnityAction&lt;T&gt; action) where T:Object&#123; ResourceRequest request = Resources.LoadAsync&lt;T&gt;(path); //返回执行外部后面的代码回来后继续加载场景直到加载完毕往后执行 yield return request; //加载完毕 action(request.asset as T);&#125; 对比:同步加载资源是完成之后才能执行之后的代码,而异步加载是另外开了一个协程所以接下来的代码继续执行同步加载是立即返回加载的对象,而异步加载是在回调函数的参数里获取到加载好的对象","categories":[],"tags":[]},{"title":"Unity设计模式之事件中心","slug":"EventCenter","date":"2021-04-28T14:16:13.671Z","updated":"2021-04-29T02:14:16.325Z","comments":true,"path":"2021/04/28/EventCenter/","link":"","permalink":"https://enderhorror.github.io/enderhorror.githubio/2021/04/28/EventCenter/","excerpt":"","text":"事件中心意图：保证一个类仅有一个事件中心,通过通知这个事件中心他再去通知所有订阅的对象主要解决：比如某些事件的广播,在游戏开始时要执行什么,或者当有玩家进入时 注意:这里用到了接口的逆变性,一个接口可以转换成某个实现了他的类型类图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/// &lt;summary&gt;/// 空接口,用于保存两种委托类型来转换/// &lt;/summary&gt;public interface I_Empty&#123;&#125;/// &lt;summary&gt;/// 带参数委托容器/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;类型&lt;/typeparam&gt;public class ActionContainer&lt;T&gt;:I_Empty&#123; public UnityAction&lt;T&gt; actionData; public ActionContainer(UnityAction&lt;T&gt; action) &#123; actionData += action; &#125; &#125;/// &lt;summary&gt;/// 无参委托容器/// &lt;/summary&gt;public class ActionContainerWithoutT: I_Empty&#123; public UnityAction actionData; public ActionContainerWithoutT(UnityAction action) &#123; actionData += action; &#125;&#125;public class EventCenter : Singleton&lt;EventCenter&gt;//这里用到了之前的单例模式&#123; //用来保存事件列表 Dictionary&lt;string, I_Empty&gt; dic = new Dictionary&lt;string, I_Empty&gt;(); /// &lt;summary&gt; /// 添加监听事件[不带参数的响应] /// &lt;/summary&gt; /// &lt;param name=&quot;EventName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;Action&quot;&gt;&lt;/param&gt; /*这里是无参数的*/ public void AddEventListener(string eventName, UnityAction action) &#123; if (dic.ContainsKey(eventName)) &#123; (dic[eventName] as ActionContainerWithoutT).actionData += action;//利用接口逆变性,把接口转换为他的一个父类 &#125; else &#123; dic.Add(eventName, new ActionContainerWithoutT(action)); &#125; &#125; /// &lt;summary&gt; /// 添加监听事件[带有参数的响应] /// &lt;/summary&gt; /// &lt;param name=&quot;EventName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;Action&quot;&gt;&lt;/param&gt; /*这里是有参数的*/ public void AddEventListener&lt;T&gt;(string eventName,UnityAction&lt;T&gt; action) &#123; if(dic.ContainsKey(eventName)) &#123; (dic[eventName] as ActionContainer&lt;T&gt;).actionData += action; &#125; else &#123; dic.Add(eventName, new ActionContainer&lt;T&gt;(action)); &#125; &#125; /// &lt;summary&gt; /// 当事件触发[带有参数] /// &lt;/summary&gt; /// &lt;param name=&quot;EvenName&quot;&gt;&lt;/param&gt; public void EventTrigger&lt;T&gt;(string eventName,T info) &#123; if(dic.ContainsKey(eventName)) &#123; (dic[eventName] as ActionContainer&lt;T&gt;).actionData(info); &#125; &#125; /// &lt;summary&gt; /// 当事件触发[带有参数] /// &lt;/summary&gt; /// &lt;param name=&quot;EvenName&quot;&gt;&lt;/param&gt; public void EventTrigger(string eventName) &#123; if (dic.ContainsKey(eventName)) &#123; (dic[eventName] as ActionContainerWithoutT).actionData(); &#125; &#125; /// &lt;summary&gt; /// 移除委托[带有参数] /// &lt;/summary&gt; /// &lt;param name=&quot;EventName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;Action&quot;&gt;&lt;/param&gt; public void RemoveAction&lt;T&gt;(string eventName,UnityAction&lt;T&gt; action) &#123; if(dic.ContainsKey(eventName)) &#123; (dic[eventName] as ActionContainer&lt;T&gt;).actionData -= action; &#125; &#125; /// &lt;summary&gt; /// 移除委托[不带有参数] /// &lt;/summary&gt; /// &lt;param name=&quot;EventName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;Action&quot;&gt;&lt;/param&gt; public void RemoveAction(string eventName, UnityAction action) &#123; if (dic.ContainsKey(eventName)) &#123; (dic[eventName] as ActionContainerWithoutT).actionData -= action; &#125; &#125; /// &lt;summary&gt; /// 清空所有事件 /// &lt;/summary&gt; public void Clear() &#123; dic.Clear(); &#125; &#125; 如何使用 123456789//添加无参数事件EvnetEnter.Instance.AddEventListener(&quot;GameOver&quot;,()=&gt;Debug.Log(&quot;游戏结束&quot;));//添加带参事件EvnetEnter.Instance.AddEventListener&lt;Player&gt;(&quot;PlayerEnter&quot;,(player)=&gt;Debug.Log($&quot;&#123;player&#125;加入了游戏&quot;));//广播无参数事件EvnetEnter.Instance.EventTrigger(&quot;GameOver&quot;);//广播带参事件EvnetEnter.Instance.EventTrigger&lt;Player&gt;(&quot;PlayerEnter&quot;,player); 这样我们就能很方便的通知订阅了这个事件的所以对象,这就是事件中心设计模式","categories":[],"tags":[]},{"title":"Unity设计模式单例模式","slug":"Singleton","date":"2021-04-27T05:58:49.952Z","updated":"2021-04-27T06:20:05.450Z","comments":true,"path":"2021/04/27/Singleton/","link":"","permalink":"https://enderhorror.github.io/enderhorror.githubio/2021/04/27/Singleton/","excerpt":"","text":"单例模式意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决：一个全局使用的类频繁地创建与销毁。 例子:有一个GameManger负责管理游戏的规则 123456789101112131415161718192021222324class GameManager&#123; #region单例模板 private static T instance; private GameManager()&#123;&#125;//私有构造函数,防止在外部被构造 //设为静态可以通过类名.成员直接获取 public static T Instance &#123; get &#123; if (instance != null) return instance;//如果instance存在就返回他 return instance = new T();//如果不存在就创建一个新实例 &#125; private set =&gt; instance = value;//set设为私有防止单例被外部修改 &#125; #endregion public void StartGame()&#123;/*...*/&#125; public void StopGame()&#123;/*...*/&#125;&#125; 当我们需要开始游戏时只需要直接用类名.函数调用就可以调用 1GameManager.Instance.StartGame(); 优化游戏内不止一个单例,还会有什么AudioManager,DataManager等等,如果都要在每个类里面加样板代码是非常麻烦的所以我们可以使用泛型类来自动实现单例模板代码 12345678910111213141516public class Singleton&lt;T&gt; where T : new()//T必须可以被实例化&#123; private static T instance; private GameManager()&#123;&#125;//私有构造函数,防止在外部被构造 public static T Instance &#123; get &#123; if (instance != null) return instance; return instance = new T(); &#125; private set =&gt; instance = value; &#125;&#125; 经过上面修改我们的GameManager可以改成 123456class GameManager : Singleton&lt;GameManager&gt;&#123; public void StartGame()&#123;/*...*/&#125; public void StopGame()&#123;/*...*/&#125;&#125; 这样我们就实现了自动单例 Unity延伸如果我们要使用MonoBehaviour里的函数那要怎么实现单例,因为MonoBehaviour的子类是不可以实例化的 那么我们可以把实例化改成AddComponent,就相当于创建了这个组件 12345678910111213141516public class MonoSingleton&lt;T&gt; : MonoBehaviour where T: MonoBehaviour&#123; private static T instance; public static T Instance &#123; get &#123; if (instance != null) return instance; GameObject go = new GameObject(typeof(T).Name);//新创建一个GameObject用于挂载我们的Component return instance = go.AddComponent&lt;T&gt;(); &#125; protected set =&gt; instance = value; &#125;&#125; 这样我们就实现了Mono单例","categories":[],"tags":[]},{"title":"Unity设计模式之观察者模式","slug":"MangerCustomerMode","date":"2021-04-24T07:46:21.248Z","updated":"2021-04-24T07:52:16.159Z","comments":true,"path":"2021/04/24/MangerCustomerMode/","link":"","permalink":"https://enderhorror.github.io/enderhorror.githubio/2021/04/24/MangerCustomerMode/","excerpt":"","text":"Unity设计模式之观察者模式意图:定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 例子:暂停功能设计框架 一个中心化的Manager管理多个对象 例如:我在MC中摧毁了一个刷怪笼,他生成的怪也要全部去世.那么我不用一个个通知到生成的怪身上,而是直接通知刷怪笼,清楚你刷的所有怪 类图: 暂停接口 12345public interface IPause&#123; void Pause(); void Resume();&#125; 123456789101112131415161718192021222324252627282930313233343536public class PauseManager&#123; private static PauseManager instance; public static PauseManager Instance &#123; get &#123; if (instance != null) return instance; return instance = new PauseManager(); &#125; private set =&gt; instance = value; &#125; private List&lt;IPause&gt; customer = new List&lt;IPause&gt;(); public void Add(IPause item) =&gt; customer.Add(item); public void Remove(IPause item) =&gt; customer.Remove(item); public void Pasue() &#123; foreach (var item in customer) &#123; item.Pause(); &#125; &#125; public void Resume() &#123; foreach (var item in customer) &#123; item.Resume(); &#125; &#125;&#125; 12345678910111213public class Player : MonoBehaviour, IPause&#123; void Start() =&gt; PauseManager.Instance.Add(this); void OnDestroy() =&gt; PauseManager.Instance.Remove(this); void IPause.Pause() &#123; //要暂停时执行的代码 &#125; void IPause.Resume() &#123; //要恢复执行的代码 &#125;&#125;","categories":[],"tags":[]},{"title":"Unity数据存储方式","slug":"UnitySaveMethod","date":"2021-04-24T06:49:29.479Z","updated":"2021-04-24T07:45:18.862Z","comments":true,"path":"2021/04/24/UnitySaveMethod/","link":"","permalink":"https://enderhorror.github.io/enderhorror.githubio/2021/04/24/UnitySaveMethod/","excerpt":"","text":"数据存储 PlayerPrefab优点:方便使用,Unity自带缺点:不适合储存大量数据,不能网络传输,只能储存的数据类型单一,只推荐调试时使用.不方便修改,安全性一般 例子: 12345PlayerPrefs.SetString(&quot;Name&quot;,&quot;张三&quot;);PlayerPrefs.SetInt(&quot;ID&quot;,123456);PlayerPrefs.SetFloat(&quot;HP&quot;,100.0f);PlayerPrefs.Save();//保存数据PlayerPrefs.GetString(&quot;Name&quot;);//获取数据 JSON优点:Unity自带方便使用,能储存大量数据,可以储存较多数据类型,方便网络传输,方便编辑缺点:存储数据格式单一例子:Json文件12345&#123; &quot;name&quot;:&quot;Dr Charles&quot;, &quot;lives&quot;:3, &quot;health&quot;:0.8&#125; 代码12345678910111213141516171819202122[System.Serializable]//标记为可序列化public struct PlayerData&#123; public string name; public int lives; public float health;&#125;public class PlayerInfo&#123; //读取Json数据,转换为PlayerInfo类型 public static PlayerInfo CreateFromJSON(string jsonString) &#123; return JsonUtility.FromJson&lt;PlayerData&gt;(jsonString); &#125; //存储Json数据 public string SaveToString() &#123; return JsonUtility.ToJson(this); &#125; &#125; 二进制优点:可以储存任何数据类型,安全性高缺点:不能编辑,非常难阅读内部数据例子:1234567891011121314151617181920212223242526public class BinarySerializer : MonoBehaviour &#123; string filePath = Directory.GetCurrentDirectory() + &quot;/binaryFile.txt&quot;; void Start () &#123; List&lt;string&gt; listPers = new List&lt;string&gt;&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;; SerializeMethod (listPers); // 序列化 DeserializeMethod(); // 反序列化 &#125; void DeserializeMethod()// 二进制反序列化 &#123; FileStream fs = new FileStream (filePath, FileMode.Open); BinaryFormatter bf = new BinaryFormatter (); List&lt;Person&gt; list = bf.Deserialize (fs) as List&lt;Person&gt;; fs.Close (); &#125; void SerializeMethod(List&lt;string&gt; listPers) // 二进制序列化 &#123; FileStream fs = new FileStream (filePath, FileMode.Create); BinaryFormatter bf = new BinaryFormatter (); bf.Serialize (fs, listPers); fs.Close (); &#125;&#125; Excel优点:可以使用Excel表格编写,非常容易阅读和编辑缺点:使用起来需要去定位行和列,安全性差例子:使用ClosedXML去读取Excel表格 其他","categories":[],"tags":[]}],"categories":[],"tags":[]}